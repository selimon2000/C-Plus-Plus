// Add documentation to our own implemented functions and not the ones in interface (Personal Note)

 


/*!

 

*/

 

// without this gap between two doxygen definition, the last group does not get
// populated properly for some reason.

 

/*!
@mainpage Assignment 2:
 @section  Intro

 

This Assignment simulates both the quadcopter and Audi platforms with the gazebo simulator, to reach a specific target(s).
There are 3 modes - BASIC, ADVANCED, and SUPER.

BASIC mode: when run, platform(s) should execut simulataneously, going through goals in seperate threads, whilst computing distance travelled.


 @section  Tests

 

There are many unit tests written to test the functionality of the code for the platforms.
 

\image html results.png "Figure 4. Output of a completed mission" width=496px height=110px  

The skeleton code presents a controller interface for the different platforms: A quadcopter and an unmanned ground vehicle (Audi).
These platforms are ran in the simulator that are ran through a ros package.

 

\image html uav.png "Figure 1. UAV" width=200px height=200px

\image html ugv.png "Figure 2. UGV" width=200px height=200px    

\image html multi.png "Figure 3. Multi" width=200px height=200px

@section Running 
To run the system needs the following components to run:
- Opening the simulators
\verbatim
    roslaunch gazebo_tf ugv.launch
\endverbatim

 

- Running the mission (requires a build directory from cmake)
\verbatim
    ./build/test/missionTests
\endverbatim

 - Running the mission (requires a build directory from cmake)
\verbatim
    ./build/test/missionTests
\endverbatim

- Ackerman Tests:

 - audiCheckOriginToDestination
\verbatim
    ./build/test/audiCheckOriginToDestination
\endverbatim

 - audiReachGoal
\verbatim
    ./build/test/audiReachGoal
\endverbatim

 - audiReachGoalAllGoals
\verbatim
    ./build/test/audiReachGoalAllGoals
\endverbatim

 - audiReachGoals
\verbatim
    ./build/test/audiReachGoals
\endverbatim

 - audiReachGoalsAdvanced
\verbatim
    ./build/test/audiReachGoalsAdvanced
\endverbatim

 - audiReachGoalsAdvancedAllGoals
\verbatim
    ./build/test/audiReachGoalsAdvancedAllGoals
\endverbatim

 - audiReachGoalsAdvancedAllGoals2
\verbatim
    ./build/test/audiReachGoalsAdvancedAllGoals2
\endverbatim

 - audiReachGoalsAllGoals
\verbatim
    ./build/test/audiReachGoalsAllGoals
\endverbatim


- Quadcopter Tests:

 - quadcopterCheckOriginToDestination
\verbatim
    ./build/test/quadcopterCheckOriginToDestination
\endverbatim

 - quadcopterReachGoal
\verbatim
    ./build/test/quadcopterReachGoal
\endverbatim

 - quadcopterReachGoalAllGoals
\verbatim
    ./build/test/quadcopterReachGoalAllGoals
\endverbatim

 - quadcopterReachGoals
\verbatim
    ./build/test/quadcopterReachGoals
\endverbatim

 - quadcopterReachGoalsAdvanced
\verbatim
    ./build/test/quadcopterReachGoalsAdvanced
\endverbatim

 - quadcopterReachGoalsAdvancedAG
\verbatim
    ./build/test/quadcopterReachGoalsAdvancedAG
\endverbatim

 - quadcopterReachGoalsAdvancedAG2
\verbatim
    ./build/test/quadcopterReachGoalsAdvancedAG2
\endverbatim

 - quadcopterReachGoalsAllGoals
\verbatim
    ./build/test/quadcopterReachGoalsAllGoals
\endverbatim

 @section  Output

 

The output in the simulator after running the test that runs through the goals should result in a pass
where the car reaches a stop within 0.5m of the goal.

 

\image html results.png "Figure 4. Output of a completed mission" width=496px height=110px









 
 @section  TSP-Travelling_Salesman

 

The Travelling Salesman Problem is how to efficiently travel to the goals, whilst having the minimum cost (distance).
There are many ways to solve this, such as using branches with BFS/DFS Search Algorithms.

In this assignment, the Brute Force Approach is being used, which is relatively inefficient, and works by calculating the cost of all possible permutations.

For Example, given the diagram:
\image html tsp_1.png "Figure 4. Output of a completed mission" width=750px height=850px

An Adjacency List / Graph can be developed:
\image html tsp_2.png "Figure 4. Output of a completed mission" width=300 px height=120px

All possible Permutations can be iterated, where the least costly approach is saved:
\image html tsp_3.png "Figure 4. Output of a completed mission" width=215px height=110px


The Brute force method in this assignment is being implemented in 2 methods:

- for the quadcopter, an adjacency graph is being generated, where a tsp search is conducted
- for the audi (ackerman steered vehicle), where all permutations are generated first. This is necessary as the yaw of each position in the permutation affects
  the distance calculation and possibility of it reaching the goal.

In both implementations the current position is inputted as a 'starter', ensuring that all permutations and calculatoins start from the origin.















 @section  Advanced_Mode

 

The Advanced Mode seeks to ensure that the platform travels to goals supplied whilst reducing cost.

The advanced mode works by converting the list of goals into a graph/adjacency list, and then iterating through all possible permuations using TSP Brute Force search.

It is important to note that the current position of the platform is passed as a Point, where the permutation will start from.
This is present in the image below, where all permutations start with a '0'.

 

\image html advanced_mode.png "Figure 4. Output of a completed mission" width=174px height=922px
















 @section  Super_Mode

 

Goals supplied are rearranged across platforms, so that max distance travelled is minimum.














@n By Selimon Shukurzad
@n Selimon.Shukurzad-1@student.uts.edu.au
*/